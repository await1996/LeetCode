#### 1.二进制中1的个数

```java
//位运算最常用思路，异或，n&=n-1;可消除二进制中最后一个1
public class Solution {
    public int NumberOf1(int n) {
        int cnt=0;
        while(n!=0){
            n&=n-1;
            cnt++;
        }
        return cnt;
    }
}
```
#### 2.数值的整数次方

```java
//递归，对exponent是否为负数和奇数做判断
public class Solution {
    public double Power(double base, int exponent) {
        if(exponent==0)
            return 1.0;
        
        int flag=0;
        double res=1.0;
        if(exponent<0){
            flag=1;
            exponent=-exponent;
        }
        if(exponent%2==1){
            res=base;
        }
        
        double res0=Power(base,exponent/2);
        res*=res0*res0;
        
        return flag==0 ? res : 1/res;
        
  }
}
```
#### 3.调整数组顺序使奇数位于偶数前面

```java
public class Solution {
    public void reOrderArray(int [] array) {
        //方法1：冒泡，时间n平方，空间1
        /*for(int i=0;i<=array.length-2;i++){
            for(int j=0;j<=array.length-i-2;j++){
                if(array[j]%2==0 && array[j+1]%2==1){
                    int temp=array[j];
                    array[j]=array[j+1];
                    array[j+1]=temp;
                }
            }
        }*/
        //方法2：new数组，时间n，空间n
        int[] newArr=new int[array.length];
        int cnt=0;
        for(int i=0;i<array.length;i++){
            if(array[i]%2==1)
                newArr[cnt++]=array[i];
        }
        for(int i=0;i<array.length;i++){
            if(array[i]%2==0)
                newArr[cnt++]=array[i];
        }
        for(int i=0;i<array.length;i++){
            array[i]=newArr[i];
        }
        
    }
}
```

#### 4.链表中倒数第k个结点

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null)
            return null;
        
        ListNode cur=head;
        int cnt=0;
        //算长度
        while(cur!=null){
            cnt++;
            cur=cur.next;
        }
        
        if(cnt<k)
            return null;
        
        cnt-=k;
        cur=head;
        //走对应长度
        while(cnt-->0){
            cur=cur.next;
        }
        return cur;
    }
}
```

#### 5.反转链表

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        //方法1：头插法
        /*ListNode fHead=new ListNode(-1);
        ListNode cur=head;
        while(cur!=null){
            ListNode next=cur.next;
            
            cur.next=fHead.next;
            fHead.next=cur;
            cur=next;
        }
        return fHead.next;*/
        //方法2：递归
        if(head==null)
            return null;
        if(head.next==null)
            return head;
        
        ListNode next=head.next;
        head.next=null;
        ListNode newHead=ReverseList(next);
        next.next=head;
        
        return newHead;
    }
}
```

#### 6.合并两个排序的链表

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        //方法1：归并排序merge过程
        /*ListNode cur1=list1;
        ListNode cur2=list2;
        ListNode fHead=new ListNode(-1);
        ListNode cur=fHead;
        while(cur1!=null && cur2!=null){
            if(cur1.val<=cur2.val){
                cur.next=cur1;
                cur1=cur1.next;
                cur=cur.next;
            }else{
                cur.next=cur2;
                cur2=cur2.next;
                cur=cur.next;
            }
        }
        if(cur1!=null){
            cur.next=cur1;
        }
        if(cur2!=null){
            cur.next=cur2;
        }
        return fHead.next;*/
        //方法2：递归
        if(list1==null)
            return list2;
        if(list2==null)
            return list1;
        if(list1.val<=list2.val){
            ListNode next = Merge(list1.next,list2);
            list1.next=next;
            return list1;
        }else{
            ListNode next = Merge(list1,list2.next);
            list2.next=next;
            return list2;
        }
    }
}
```

#### 7.树的子结构

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root2==null)
            return false;
        if(root1==null)
            return false;
        //root1左树存在root2子结构、root1右树存在root2子结构、root2就是root1子结构
        if(HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2) || isSubtree(root1,root2))
            return true;
        return false;
    }
    //当前树结构是否满足子结构
    public boolean isSubtree(TreeNode root1,TreeNode root2){
        if(root2==null)
            return true;
        if(root1==null)
            return false;
        
        if(root1.val==root2.val && isSubtree(root1.left,root2.left) && isSubtree(root1.right,root2.right))
            return true;
        return false;
    }
}
```

#### 8.二叉树的镜像

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
//经典递归，利用左、右子树递归值，构造出根节点递归值
public class Solution {
    public void Mirror(TreeNode root) {
        if(root==null)
            return;
        
        TreeNode left=root.left;
        TreeNode right=root.right;
        
        Mirror(root.left);
        Mirror(root.right);
        
        root.left=right;
        root.right=left;
        
    }
}
```

#### 9.顺时针打印矩阵

```java
//定义4个值，对应上下左右边界，
//特别注意行为奇数或列为奇数的特殊情况，在循环前两次后，进行一次判断
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList<Integer> res=new ArrayList<>();
        if(matrix.length==0)
            return res;
        
        int minRow=0;
        int maxRow=matrix.length-1;
        int minCol=0;
        int maxCol=matrix[0].length-1;
        
        while(minRow<=maxRow && minCol<=maxCol){
            for(int j=minCol;j<=maxCol;j++){
                res.add(matrix[minRow][j]);
            }
            minRow++;
            for(int i=minRow;i<=maxRow;i++){
                res.add(matrix[i][maxCol]);
            }
            maxCol--;
            //最后一行、最后一列 特殊情况
            if(minRow>maxRow || minCol>maxCol)
                break;
            for(int j=maxCol;j>=minCol;j--){
                res.add(matrix[maxRow][j]);
            }
            maxRow--;
            for(int i=maxRow;i>=minRow;i--){
                res.add(matrix[i][minCol]);
            }
            minCol++;
        }
        return res;
    }
}
```

#### 10.包含min函数的栈

```java
import java.util.Stack;

public class Solution {
    //维护一个最小栈
    Stack<Integer> stack=new Stack<>();
    Stack<Integer> minStack=new Stack<>();
    int min=Integer.MAX_VALUE;
    public void push(int node) {
        min=Math.min(min,node);
        stack.push(node);
        minStack.push(min);
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
}
```

