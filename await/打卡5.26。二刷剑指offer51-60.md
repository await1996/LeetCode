#### 1.构建乘积数组

```java
import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
        if(A.length==0)
            return A;
        //只能用乘法，可以构造B数组的，左数组B1和右数组B2
        int[]B1=new int[A.length];
        int[]B2=new int[A.length];
        int[]B=new int[A.length];
        
        B1[0]=1;
        for(int i=1;i<A.length;i++){
            B1[i]=B1[i-1]*A[i-1];
        }
        B2[A.length-1]=1;
        for(int i=A.length-2;i>=0;i--){
            B2[i]=B2[i+1]*A[i+1];
        }
        for(int i=0;i<A.length;i++){
            B[i]=B1[i]*B2[i];
        }
        return B;
    }
}
```
#### 2.正则表达式匹配

```java
//正则表达式
```
#### 3.表示数值的字符串

```java
//正则表达式
```

#### 4.字符流中第一个不重复的字符

```java
import java.util.*;
public class Solution {
    //使用map（或者字符数组记录字符出现次数），使用StringBuffer（好方案，需要顺序记录，有需要快速查找）记录数组出现顺序
    Map<Character,Integer>map=new HashMap<>();
    StringBuffer sb=new StringBuffer();
    //Insert one char from stringstream
    public void Insert(char ch)
    {
        if(map.containsKey(ch)){
            map.put(ch,map.get(ch)+1);
            //res.remove(ch);
        }else{
            map.put(ch,1);
            sb.append(ch);
        }
        
    }
  //return the first appearence once char in current stringstream
    public char FirstAppearingOnce()
    {
        for(int i=0;i<sb.length();i++){
            char ch=sb.charAt(i);
            if(map.get(ch)==1)
                return ch;
        }
        return '#';
    }
}
```

#### 5.链表中环的入口结点

```java
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
        if(pHead==null)
            return null;
        ListNode cur1=pHead;
        ListNode cur2=pHead;
        boolean flag=true;
        while(cur1!=null && cur1.next!=null){
            cur1=cur1.next.next;
            cur2=cur2.next;
            
            //判断是否有环
            if(cur1==cur2){
                flag=false;
                break;
            }
                
        }
        if(flag)
            return null;
        
        cur1=pHead;
        while(cur1!=cur2){
            cur1=cur1.next;
            cur2=cur2.next;
        }
        
        return cur1;
    }
}
```

#### 6.删除链表中重复的结点

```java
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead)
    {
        ListNode fHead=new ListNode(-1);
        fHead.next=pHead;
        
        ListNode cur=pHead;
        ListNode pre=fHead;
        
        while(cur!=null){
            boolean flag=false;
            //如果满足，当前数值节点要过滤
            //循环结束时在当前值的最后一个结点，因此在循坏外，还要next，并直接进到下一次循环
            while(cur!=null && cur.next!=null && cur.val==cur.next.val){
                flag=true;
                cur=cur.next;
            }
            if(flag){
                cur=cur.next;
                
            }else{
                pre.next=cur;
                pre=pre.next;
                cur=cur.next;
            }
        }
        //这一步不可少，做链表题还是要仔细分析，直到指向null
        pre.next=null;
        return fHead.next;
    }
}
```

#### 7.二叉树的下一个结点

```java
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode==null)
            return null;
        
        if(pNode.right!=null){
             TreeLinkNode cur=pNode.right;
            while(cur.left!=null){
                cur=cur.left;
            }
            return cur;
        }else{
            TreeLinkNode cur=pNode.next;
            TreeLinkNode pre=pNode;
            while(cur!=null && cur.left!=pre){
                pre=cur;
                cur=cur.next;
            }
            return cur;
        }
    }
}
```

#### 8.对称的二叉树

```java
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        //方法一：使用层序遍历，但是与一般层序遍历不同，需要把空节点也算上，不然不能判断是否对称
        //方法二：递归，看左树与右树是否对称，等价于看左树左与右树右、左树右与右树左是否对称
        if(pRoot==null)
            return true;
        return isSym(pRoot.left,pRoot.right);
    }
    
    public boolean isSym(TreeNode left,TreeNode right){
        if(root1==null && root2==null)
            return true;
        if(root1==null || root2==null)
            return false;
        
        if(root1.val!=root2.val)
            return false;
        
        return isSym(root1.left,root2.right) && isSym(root1.right,root2.left);
    }
}
```

#### 9.按之字形顺序打印二叉树

```java
import java.util.*;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> res=new ArrayList<>();
        ArrayList<TreeNode> list=new ArrayList<>();
        
        if(pRoot==null)
            return res;
        list.add(pRoot);
        boolean flag=false;
        while(list.size()>0){
            int cnt=list.size();
            ArrayList<Integer> res0=new ArrayList<>();
            while(cnt-->0){
                TreeNode cur=list.remove(0);
                res0.add(cur.val);
                if(cur.left!=null)
                    list.add(cur.left);
                if(cur.right!=null)
                    list.add(cur.right);
            }
            if(flag)
                Collections.reverse(res0);
            flag=!flag;
            res.add(res0);
        }
        return res;
    }

}
```

#### 10.把二叉树打印成多行

```java
import java.util.ArrayList;


/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> res=new ArrayList<>();
        ArrayList<TreeNode> list=new ArrayList<>();
        
        if(pRoot==null)
            return res;
        list.add(pRoot);
        
        while(list.size()>0){
            int cnt=list.size();
            
            ArrayList<Integer> res0=new ArrayList<>();
            while(cnt-->0){
                TreeNode cur=list.remove(0);
                res0.add(cur.val);
                
                if(cur.left!=null)
                    list.add(cur.left);
                
                if(cur.right!=null)
                    list.add(cur.right);
            }
            res.add(res0);
        }
        return res;
    }
    
}
```

