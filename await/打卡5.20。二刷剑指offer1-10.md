#### 1.二维数组中的查找

```java
//直接遍历需要m*n，这样只需要m+n
public class Solution {
    public boolean Find(int target, int [][] array) {
        if(array.length==0)
            return false;
        
        int row=0;
        int col=array[0].length-1;
        
        while(0<=row && row<array.length && 0<=col && col<array[0].length){
            if(array[row][col]<target){
                row++;
            }else if(array[row][col]==target){
                return true;
            }else{
                col--;
            }
        }
        return false;
    }
}
```
#### 2.替换空格

```java
//直接原地完成字符串替换，常见思路就是从后面往前面放字符，利用双指针，降低空间复杂度
public class Solution {
    public String replaceSpace(StringBuffer str) {
        if(str.length()==0)
            return "";
        
        int len1=str.length();
    	for(int i=0;i<len1;i++){
            if(str.charAt(i)==' '){
                str.append("  ");
            }
        }
        int len2=str.length();
        
        int i=len1-1;
        int j=len2-1;
        
        while(i<j){
            char ch=str.charAt(i);
            if(ch==' '){
                str.setCharAt(j--,'0');
                str.setCharAt(j--,'2');
                str.setCharAt(j--,'%');
                
            }else{
                str.setCharAt(j--,ch);
            }
            i--;
        }
        return str.toString();
    }
}
```
#### 3.从尾到头打印链表

```java
//先利用头插法反转链表，再遍历链表
mport java.util.*;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> res=new ArrayList<>();
        
        ListNode fHead=new ListNode(-1);
        ListNode cur=listNode;
        
        while(cur!=null){
            ListNode next=cur.next;
            
            cur.next=fHead.next;
            fHead.next=cur;
            cur=next;
        }
        
        cur=fHead.next;
        while(cur!=null){
            res.add(cur.val);
            cur=cur.next;
        }
        return res;
    }
}
```

#### 4.重建二叉树

```java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
//利用递归，获得左树、右树，再用获取到的左右树构造出最后结果

public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length==0)
            return null;
        
        return getTree(pre,0,pre.length-1,in,0,in.length-1);
    }
    
    public TreeNode getTree(int[]pre,int preL,int preR,int[] in,int inL,int inR){
        if(preL>preR)
            return null;
        
        int target=pre[preL];
        int lenL=0;
        for(int i=inL;i<=inR;i++){
            if(in[i]==target){
                lenL=i-inL;
                break;
            }
        }
        
        TreeNode root=new TreeNode(target);
        root.left=getTree(pre,preL+1,preL+lenL,in,inL,inL+lenL-1);
        root.right=getTree(pre,preL+lenL+1,preR,in,inL+lenL+1,inR);
        
        return root;
    }
}
```

#### 5.用两个栈实现队列

```java
//利用栈2进行一次转换，每次都倒干净就可以
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        while(!stack1.isEmpty()){
            stack2.push(stack1.pop());
        }
        stack1.push(node);
        while(!stack2.isEmpty()){
            stack1.push(stack2.pop());
        }
    }
    
    public int pop() {
        return stack1.pop();
    }
}
```

#### 6.旋转数组的最小数字

```java
//二分法经典实用，注意当前值是否有可能，有可能边界就包括当前位置，否则不包括
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length==0)
            return 0;
        
        int left=0;
        int right=array.length-1;
        int target=array[right];
        while(left<=right){
            if(left==right){
                return array[left];
            }
            
            int mid=left+(right-left)/2;
            
            if(array[mid]<=target){
                //mid有可能是要找的数
                right=mid;
            }else{
                //mid不可能是要找的数
                left=mid+1;
            }
        }
        return 0;
    }
}
```

#### 7.斐波那契数列

```java
public class Solution {
    public int Fibonacci(int n) {
        //方法1：递归，效率不高，重复计算。改进：可使用记忆化搜索+递归
        //方法2：动态规划,使用length长度数组。改进：只使用三个数即可记录
        if(n==0)
            return 0;
        if(n==1)
            return 1;
        
        int a=0;
        int b=1;
        int c=1;
        
        while(n-->1){
            c=a+b;
            a=b;
            b=c;
        }
        return c;
        
    }
}
```

#### 8.跳台阶，同斐波那契数列

```java

```

#### 9.变态跳台阶

```java
//找规律
public class Solution {
    public int JumpFloorII(int target) {
        return (int)Math.pow(2,target-1);
    }
}
```

#### 10.矩形覆盖，同斐波那契数列

```java

```

