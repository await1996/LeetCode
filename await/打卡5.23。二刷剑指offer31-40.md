#### 1.整数中1出现的次数（从1到n整数中1出现的次数）

```java
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
        int cnt=0;
        for(int i=1;i<=n;i++){
            int temp=i;
            while(temp>0){
                if(temp%10==1)
                    cnt++;
                temp/=10;
            }
        }
        return cnt;
    }
}
          
```

#### 2.把数组排成最小的数

```java
import java.util.*;

public class Solution {
    public String PrintMinNumber(int [] numbers) {
        String[] strNum=new String[numbers.length];
        for(int i=0;i<numbers.length;i++){
            strNum[i]=numbers[i]+"";
        }
        //贪心，此处贪法为，求字符串组合最小值，通过两个字符串str1+str2与str2+str1大小比较，将字符串数组较小的排前面
        Arrays.sort(strNum,(str1,str2)->(str1+str2).compareTo(str2+str1));
        StringBuffer sb=new StringBuffer();
        for(int i=0;i<strNum.length;i++){
            sb.append(strNum[i]);
        }
        return sb.toString();
    }
}
```

#### 3.丑数

```java
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        //方法1：暴力遍历
        //方法2：记录2,3,5使用次数，下一个数肯定是，dp[cnt2]*2,dp[cnt3]*3,dp[cnt5]*5,当中一个数
        if(index==0)
            return 0;
        
        int cnt2=0;
        int cnt3=0;
        int cnt5=0;
        
        int[]dp=new int[index];
        dp[0]=1;
        for(int i=1;i<index;i++){
            int temp=Math.min(Math.min(dp[cnt2]*2,dp[cnt3]*3),dp[cnt5]*5);
            dp[i]=temp;
            if(temp==dp[cnt2]*2)
                cnt2++;
            if(temp==dp[cnt3]*3)
                cnt3++;
            if(temp==dp[cnt5]*5)
                cnt5++;
        }
        
        return dp[index-1];
    }
}
```

#### 4.第一个只出现一次的字符

```java
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        //1.使用hashmap记录出现次数
        //HashMap<Character,Integer>map=new HashMap<>();
        //2.因为全是字母，使用数组记录出现次数，效率更高
        if(str.length()==0)
            return -1;
        
        HashMap<Character,Integer>map=new HashMap<>();
        for(int i=0;i<str.length();i++){
            char ch=str.charAt(i);
            if(map.containsKey(ch)){
                map.put(ch,map.get(ch)+1);
            }else{
                map.put(ch,1);
            }
        }
        
        for(int i=0;i<str.length();i++){
            if(map.get(str.charAt(i))==1)
                return i;
        }
        
        return -1;
    }
}
```

#### 5.数组中的逆序对

```java
//类似于做归并排序，好题
public class Solution {
    //此处先准备好一个数组，防止在递归内部不断new数组，优化空间复杂度
    int[]newArr;
    public int InversePairs(int [] array) {
        if(array.length<=1)
            return 0;
        newArr=new int[array.length];
        return getInver(array,0,array.length-1);
    }
    
    public int getInver(int[]arr,int left,int right){
        if(left>=right)
            return 0;
        
        int mid=left+(right-left)/2;
        
        int cnt1=getInver(arr,left,mid);
        int cnt2=getInver(arr,mid+1,right);
        
        int cnt=0;
        int l1=left;
        int l2=mid+1;
        
        int i=left;
        while(l1<=mid && l2<=right){
            if(arr[l1]<=arr[l2]){
                newArr[i++]=arr[l1++];
            }else{
                //此时l2往右走，以l2为标准算cnt
                newArr[i++]=arr[l2++];
                cnt+=mid-l1+1;
                cnt%=1000000007;
            }
        }
        while(l1<=mid){
            newArr[i++]=arr[l1++];
        }
        while(l2<=right){
            newArr[i++]=arr[l2++];
        }
        for(int j=left;j<=right;j++){
            arr[j]=newArr[j];
        }
        return (cnt+cnt1+cnt2)%1000000007;
    }
}
```

#### 6.两个链表的第一个公共结点

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        //方法1：先算出两个链表长度，再让长的那个先走对应步数，再一起走
        //方法2：链表1，a+c，链表2，b+c。所以链表1走到null时从pHead2开始走。链表2走到null时从pHead1开始走
        ListNode cur1=pHead1;
        ListNode cur2=pHead2;
        while(cur1!=cur2){
            cur1 = cur1==null ? pHead2 : cur1.next;
            cur2 = cur2==null ? pHead1 : cur2.next;
        }
       return cur1;
    }
}
```

#### 7.数字在排序数组中出现的次数

```java
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
        //先二分找该数，再双指针确定该数个数，时间logn，空间1
        if(array.length==0)
            return 0;
        
        int left=0;
        int right=array.length-1;
        
        while(left<=right){
            int mid=left+(right-left)/2;
            if(array[mid]<k){
                left=mid+1;
            }else if(array[mid]==k){
                int l1=mid;
                int l2=mid;
                while(l1>=0 && array[l1]==k){
                    l1--;
                }
                while(l2<array.length && array[l2]==k){
                    l2++;
                }
                return l2-l1-1;
            }else{
                right=mid-1;
            }
        }
        return 0;
    }
}
```

#### 8.二叉树的深度

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root==null)
            return 0;
        return Math.max(TreeDepth(root.left),TreeDepth(root.right))+1;
    }
}
```

#### 9.平衡二叉树

```java
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root==null)
            return true;
        
        int depth1=getDepth(root.left);
        int depth2=getDepth(root.right);
        
        if(depth1-depth2>1 || depth2-depth1>1)
            return false;
        
        return IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
    }
    public int getDepth(TreeNode root){
        if(root==null)
            return 0;
        return Math.max(getDepth(root.left),getDepth(root.right))+1;
    }
}
```

#### 10.数组中只出现一次的数字

```java
//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        //方法1：map记录，时间n，空间n
        //方法2：异或，时间n，空间1
        int res=0;
        for(int i=0;i<array.length;i++){
            res^=array[i];
        }
        //res中的1，即是num1和num2不同的位，先找出最后一个不同位，再根据该位是否为1，可将数组分成两部分，再异或
        int index=getLast1(res);
        
        int res1=0;
        int res2=0;
        for(int i=0;i<array.length;i++){
            int temp=(array[i]>>index) & 1;
            if(temp==1){
                res1^=array[i];
            }else{
                res2^=array[i];
            }
        }
        num1[0]=res1;
        num2[0]=res2;    
    }
    
    public int getLast1(int num){
        int cnt=0;
        if((num&1)!=1){
            num=num>>1;
            cnt++;
        }
        return cnt;
    }
}
```
