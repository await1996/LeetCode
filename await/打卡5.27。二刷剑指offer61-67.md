#### 1.序列化二叉树

```java
import java.util.*;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    StringBuffer sb=new StringBuffer();
    String Serialize(TreeNode root) {
        if(root==null)
            return "";
        ArrayList<TreeNode> list=new ArrayList<>();
        list.add(root);
        while(list.size()>0){
            TreeNode cur=list.remove(0);
            if(cur==null){
                sb.append("#,");
            }else{
                list.add(cur.left);
                list.add(cur.right);
                sb.append(cur.val+",");
            }
        }
        sb.deleteCharAt(sb.length()-1);
        return sb.toString();
  }
    TreeNode Deserialize(String str) {
        if(str.trim().equals(""))
            return null;
        String[]arr=str.split(",");
        TreeNode[]tree=new TreeNode[arr.length];
        //构建节点数组
        for(int i=0;i<tree.length;i++){
            if(!arr[i].equals("#")){
                tree[i]=new TreeNode(Integer.parseInt(arr[i]));
            }
        }
        int cnt=1;
        for(int i=0;i<arr.length;i++){
            if(tree[i]==null)
                continue;
            tree[i].left=tree[cnt++];
            tree[i].right=tree[cnt++];
        }
        
        return tree[0];
  }
}
```
#### 2.二叉搜索树的第k个结点

```java
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.Stack;
public class Solution {
    TreeNode KthNode(TreeNode pRoot, int k)
    {
        if(pRoot==null || k==0)
            return null;
        Stack<TreeNode> stack=new Stack<>();
        TreeNode cur=pRoot;
        
        while(cur!=null || !stack.isEmpty()){
            while(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }
            
            TreeNode temp = stack.pop();
            if(--k==0)
                return temp;
            
            cur=temp.right;
        }
        return null;
    }


}
```
#### 3.数据流中的中位数

```java
import java.util.*;
public class Solution {
    PriorityQueue<Integer> minStack=new PriorityQueue<>();
    PriorityQueue<Integer> maxStack=new PriorityQueue<>((o1,o2)->o2-o1);
    int cnt=0;
    public void Insert(Integer num) {
        //第一个数放在大根堆
        if(cnt%2==0){
            minStack.add(num);
            maxStack.add(minStack.poll());
        }else{
            maxStack.add(num);
            minStack.add(maxStack.poll());
        }
        cnt++;
    }

    public Double GetMedian() {
        if(cnt%2==1){
            return maxStack.peek()/1.0;
        }else{
            return (minStack.peek()+maxStack.peek())/2.0;
        }
    }


}
```

#### 4.滑动窗口的最大值

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size)
    {
        PriorityQueue<Integer> maxStack=new PriorityQueue<>((o1,o2)->o2-o1);
        ArrayList<Integer> res=new ArrayList<>();
        
        int cnt=0;
        for(int i=0;i<num.length;i++){
            maxStack.add(num[i]);
            if(maxStack.size()==size){
                res.add(maxStack.peek());
                maxStack.remove(num[cnt++]);
            }
        }
        return res;
    }
}
```

#### 5.矩阵中的路径

```java
public class Solution {
    int[][]path={{1,0},{-1,0},{0,1},{0,-1}};
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        int t=0;
        char[][]arr=new char[rows][cols];
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                arr[i][j]=matrix[t++];
            }
        }
        
        
        int[][] flag=new int[rows][cols];
        int cnt=0;
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(arr[i][j]==str[0]){
                    flag[i][j]=1;
                    if(isPath(arr,rows,cols,i,j,str,flag,1))
                        return true;
                    flag[i][j]=0;
                }
               
            }
        }
        return false;
    }
    
    public boolean isPath(char[][] matrix,int rows,int cols,int i,int j,char[]str,int[][]flag,int cnt){
        if(cnt==str.length){
            return true;
        }
            
        for(int k=0;k<4;k++){
            int newi=i+path[k][0];
            int newj=j+path[k][1];
            
            if(0<=newi && newi<rows && 0<=newj && newj<cols && flag[newi][newj]==0 && matrix[newi][newj]==str[cnt]){
                flag[newi][newj]=1;
                if(isPath(matrix,rows,cols,newi,newj,str,flag,cnt+1))
                    return true;
                flag[newi][newj]=0;
            }
        }
        return false;
    }

}
```

#### 6.机器人的运动范围

```java
public class Solution {
    int[][]path={{1,0},{-1,0},{0,1},{0,-1}};
    public int movingCount(int threshold, int rows, int cols)
    {
        if(threshold<0)
            return 0;
        int[][]flag=new int[rows][cols];
        flag[0][0]=1;
        getCnt(threshold,rows,cols,0,0,flag);
        int cnt=0;
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                cnt+=flag[i][j];
            }
        }
        return cnt;
    }
    
    public void getCnt(int max,int rows,int cols,int i,int j,int[][]flag){
        for(int k=0;k<4;k++){
            int newi=i+path[k][0];
            int newj=j+path[k][1];
            
            if(0<=newi && newi<rows && 0<=newj && newj<cols && flag[newi][newj]==0 && getSum(newi,newj)<=max){     
                flag[newi][newj]=1;
                getCnt(max,rows,cols,newi,newj,flag);
                
            }
        }
    }
    
    public int getSum(int n1,int n2){
        int cnt=0;
        while(n1>0){
            cnt+=n1%10;
            n1/=10;
        }
        while(n2>0){
            cnt+=n2%10;
            n2/=10;
        }
        return cnt;
    }
}
```

#### 7.剪绳子

```java
public class Solution {
    public int cutRope(int target) {
        if(target==2)
            return 1;
        if(target==3)
            return 2;
        
        int[]dp=new int[target+1];
        //经典两重循环解决动态规划
        for(int i=1;i<=target;i++){
            dp[i]=i;
            for(int j=1;j<=i/2;j++){
                dp[i]=Math.max(dp[j]*dp[i-j],dp[i]);
            }
        }
        return dp[target];
    }
}
```

