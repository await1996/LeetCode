#### 1.栈的压入、弹出序列

```java
//使用栈模拟压入和弹出，看最后栈是否为空
import java.util.*;

public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        //使用栈模拟压入弹出操作
        int j=0;
        Stack<Integer> stack=new Stack<>();
        for(int i=0;i<pushA.length;i++){
            stack.push(pushA[i]);
            while(!stack.isEmpty() && stack.peek()==popA[j]){
                stack.pop();
                j++;
            }
        }
        return stack.isEmpty();
    }
}
```
#### 2.从上往下打印二叉树

```java
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        //二叉树的层序遍历，list存放下一层的节点，res存放所有节点数值
        ArrayList<Integer>res=new ArrayList<>();
        ArrayList<TreeNode> list=new ArrayList<>();
        
        if(root==null)
            return res;
        
        list.add(root);
        while(list.size()>0){
            TreeNode cur=list.remove(0);
            if(cur.left!=null)
                list.add(cur.left);
            if(cur.right!=null)
                list.add(cur.right);
            
            res.add(cur.val);
        }
        return res;
    }
}
```
#### 3.二叉搜索树的后序遍历序列

```java
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence.length==0)
            return false;
        //数组类型递归题目，经常是将原函数构造为一个带下标的新函数，来判断在这个下标内，是否满足条件
        return isBST(sequence,0,sequence.length-1);
    }
    public boolean isBST(int[]sequence,int left,int right){
        if(left>=right)
            return true;
        
        int target=sequence[right];
        //因为可能只有左边，flag=right，可以包括这种情况
        int flag=right;
        for(int i=left;i<=right;i++){
            if(sequence[i]>target){
                flag=i;
                break;
            }
        }
        
        for(int i=flag;i<right;i++){
            if(sequence[i]<target)
                return false;
        }
        
        return isBST(sequence,left,flag-1) && isBST(sequence,flag,right-1);
    }
    
}
```

#### 4.二叉树中和为某一值的路径

```java
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/

import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
        ArrayList<ArrayList<Integer>> res=new ArrayList<>();
        ArrayList<Integer> list=new ArrayList<>();
        
        if(root==null)
            return res;
        //dfs
        getPath(root,target,res,list);
        return res;
    }
    
    public void getPath(TreeNode root,int target,
                        ArrayList<ArrayList<Integer>>res,ArrayList<Integer> list){
        if(root==null)
            return;
        //叶子结点处，左右节点为空
        if(root!=null && root.left==null && root.right==null && root.val==target){
            list.add(root.val);
            res.add(new ArrayList<>(list));
            list.remove(list.size()-1);
            return;
        }
        
        
        list.add(root.val);
        getPath(root.left,target-root.val,res,list);
        list.remove(list.size()-1);
        
        list.add(root.val);
        getPath(root.right,target-root.val,res,list);
        list.remove(list.size()-1);
    }
}
```

#### 5.复杂链表的复制

```java
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        if(pHead==null)
            return null;
        
        RandomListNode cur=pHead;
        RandomListNode temp=null;
        //复制链表，分三步，复制节点值以及next指针；复制random指针；拆分两个链表
        while(cur!=null){
            temp=new RandomListNode(cur.label);
            temp.next=cur.next;
            cur.next=temp;
            
            cur=cur.next.next;
        }
        cur=pHead;
        while(cur!=null){
            if(cur.random!=null){
                temp=cur.next;
                temp.random=cur.random.next;
            }
            cur=cur.next.next;
        }
        cur=pHead;
        RandomListNode res=cur.next;
        while(cur!=null && cur.next!=null){
            RandomListNode next=cur.next;
            
            cur.next=cur.next.next;
            cur=next;
            
        }
        cur.next=null;
        return res;
    }
}
```

#### 6.二叉搜索树与双向链表

```java
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
import java.util.*;
public class Solution {
    TreeNode first=null;
    TreeNode pre=null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        //方法1：递归中序遍历
        //inOrder(pRootOfTree);
        //return first;
        //方法2：迭代中序遍历
        TreeNode cur=pRootOfTree;
        Stack<TreeNode> stack=new Stack<>();
        while(cur!=null || !stack.isEmpty()){
            while(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }
            TreeNode temp=stack.pop();
            if(first==null){
                first=temp;
                pre=temp;
            }else{
                pre.right=temp;
                temp.left=pre;
                pre=temp;
            }
            cur=temp.right;
        }
        return first;
    }
    
    public void inOrder(TreeNode root){
        if(root==null)
            return;
        
        inOrder(root.left);
        if(first==null){
            first=root;
            pre=root;
        }else{
            pre.right=root;
            root.left=pre;
            pre=root;
        }
        inOrder(root.right);
            
    }
}
```

#### 7.字符串的排列

```java
import java.util.*;
public class Solution {
    public ArrayList<String> Permutation(String str) {
       //字符有重复，先转化为字符数组排个序
        ArrayList<String>res=new ArrayList<>();
        if(str.length()==0)
            return res;
        char[]ch=str.toCharArray();
        Arrays.sort(ch);
        
        int[] flag=new int[ch.length];
        getPer(ch,flag,"",res);
        
        return res;
    }
    
    public void getPer(char[]ch,int[]flag,String str,ArrayList<String> res){
        if(str.length()==ch.length){
            res.add(str);
            return;
        }
        
        for(int i=0;i<ch.length;i++){
            if(flag[i]==0){
                if(i>=1 && flag[i-1]==0 && ch[i-1]==ch[i])
                    continue;
                flag[i]=1;
                getPer(ch,flag,str+ch[i],res);
                flag[i]=0;
            }
        }
    }
}
```

#### 8.数组中出现次数超过一半的数字

```java
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
        //方法1：map存储，遍历一次数组放入map存出现次数，再遍历一次map的key，时间n，空间n
        //方法2：排序，再从中间数往两边走，看个数，时间n*logn，空间1
        //方法3：多数投票，求得这个数，若存在长度超过一半的数，就是该数，否则不存在。时间n，空间1
        //多数投票
        if(array.length==0)
            return 0;
        int num=array[0];
        int cnt=1;
        for(int i=1;i<array.length;i++){
            if(array[i]==num){
                cnt++;
            }else{
                cnt--;
            }
            if(cnt==0 && i<array.length-1)
                num=array[i+1];
                
        }
        cnt=0;
        for(int i=0;i<array.length;i++){
            if(array[i]==num)
                cnt++;
        }
        return 2*cnt>array.length ? num : 0;
    }
}
```

#### 9.最小的K个数

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        //方法1：大小为k的大根堆，时间n*log k，空间k
        //方法2：快排优化版，时间n，空间1
        //大根堆
        PriorityQueue<Integer> maxStack=new PriorityQueue<>((o1,o2)->o2-o1);
        ArrayList<Integer> res=new ArrayList<>();
        
        if(input.length<k)
            return res;
        
        for(int i=0;i<input.length;i++){
            maxStack.add(input[i]);
            if(maxStack.size()>k)
                maxStack.poll();
            
        }
        while(maxStack.size()>0){
             res.add(maxStack.poll());
        }
        
        return res;
    }
}
```

#### 10.连续子数组的最大和

```java
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
        //方法1：滑动窗口
        //方法2：每次求得都是包括当前值的最大值
        int sum=0;
        int max=array[0];
        for(int i=0;i<array.length;i++){
            if(sum<=0){
                sum=array[i];
            }else{
                sum+=array[i];
            }
            max=Math.max(max,sum);
        }
        return max;
    }
}
```

